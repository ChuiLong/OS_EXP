# OS原理中很重要但实验中没有对应上的知识点

## 1.上下文切换

上下文（Context）中包含了进程运行状态相关的信息，包括寄存器、CPU的状态、内存地址空间。

PCB：管理进程的数据结构，保存进程的运行状态，如进程的PC、CPU的寄存器值、进程的优先级、进程的调度状态、进程的资源使用情况等。

### 1.1 上下文切换的概念

上下文切换（Context Switch）是操作系统在运行多任务时，为了在多个任务之间切换执行而进行的操作。它涉及到保存当前任务的执行状态，并加载下一个任务的执行状态。上下文切换通常发生在以下几种情况：任务调度、中断处理、系统调用等。

### 1.2 上下文切换的步骤

1. 保存当前进程1状态到PCB中。
2. 从进程2的PCB中加载进程2的运行状态。
3. 执行进程2的指令。
4. 保存进程2状态到PCB中。
5. 从进程1的PCB中恢复进程1的运行状态。
6. 执行进程1的指令。

## 2.进程调度

在上面的上下文切换中，我们通过将运行中的进程保存到PCB中，并切换到下一个进程的运行状态，实现了进程的切换。那么现在我们就会面临一个问题，当许多程序在运行时，我们在中断了原来的进程之后，操作系统内核中的调度器 (Scheduler) 会如何选择下一个进程进行运行呢？

### 2.1 五状态模型
**状态**：创建、就绪、等待、运行、退出
创建：进程创建时，操作系统会为进程分配资源，并创建进程控制块（PCB）并保存进程信息。
就绪：进程创建成功后，操作系统会将进程加入就绪队列，等待CPU调度。
等待：进程等待某个事件发生，如文件I/O、网络I/O、设备I/O等。
运行：进程开始执行，CPU开始调度进程。
退出：进程执行完毕，操作系统会回收进程所占用的资源，并删除进程控制块。

### 2.2 挂起进程模型
某进程长时间不能运行可以换至外存——就是挂起状态
1. 单挂起模型
**状态**：创建、就绪、阻塞、挂起、运行、退出
与五状态模型相比，单挂起模型增加了挂起状态。当进程处于挂起状态时，操作系统会将进程从内存中移除，并将其保存到外存中。当进程被唤醒时，操作系统会将进程从外存中加载到内存中，并将其状态设置为就绪状态。

2. 双挂起模型
**状态**：创建、就绪、阻塞、阻塞挂起、就绪挂起、就绪、运行、退出
双挂起模型在单挂起模型的基础上，进一步细化了挂起状态。它将挂起状态分为阻塞挂起和就绪挂起两种状态。

+ 当一个在内存中的阻塞进程因为内存紧张被换出时，它进入“阻塞挂起”状态，此时它位于外存。

- 如果这个处于“阻塞挂起”的进程，它所等待的事件完成了，它的状态就会变为“就绪挂起”，但它依然停留在外存。

* “就绪挂起”状态的进程，表明它已经准备好运行，只等待被换入内存。

+ 当操作系统有空闲内存时，会将“就绪挂起”的进程换入内存，此时它的状态就变成了“就绪”，可以等待被调度器选中并在CPU上运行。

## 3.进程调度算法

### 3.1 先来先服务（FCFS）

先来先服务（First Come First Serve，FCFS）调度算法是一种简单的进程调度算法，它按照进程到达的顺序来调度进程。也就是说，先到达的进程先被调度执行，后到达的进程后执行。

### 3.2 短进程优先（SPN）

短进程优先（Shortest Process Next，SPN）调度算法是一种进程调度算法，它按照进程执行时间长短来调度进程。也就是说，执行时间最短的进程优先被调度执行。

### 3.3 最高响应比优先（HRRN）

最高响应比优先（Highest Response Ratio Next，HRRN）调度算法是一种进程调度算法，它根据进程的响应比来调度进程。响应比 = (等待时间 + 要求服务时间) / 要求服务时间。响应比越高的进程优先被调度执行。

### 3.4 时间片轮转（RR）

时间片轮转（Round Robin，RR）调度算法是一种进程调度算法，它按照进程到达的顺序来调度进程，并为每个进程分配一个固定的时间片。当一个进程的时间片用完时，操作系统会将其从就绪队列中移除，并将其加入等待队列。然后，操作系统会从等待队列中选择下一个进程进行调度执行。

### 3.5 多级队列调度（MQ）

多级队列调度（Multilevel Queue，MQ）是一种进程调度算法，它将进程按照优先级划分为多个队列，并使用不同的调度算法来调度每个队列中的进程。

### 3.6 多级反馈队列调度（MLFQ）

多级反馈队列调度（Multilevel Feedback Queue，MLFQ）是一种进程调度算法，它将进程按照优先级划分为多个队列，并使用不同的调度算法来调度每个队列中的进程。

与多级队列调度不同的是，MLFQ算法允许进程在队列之间移动。当一个进程在一个队列中等待的时间过长时，操作系统会将该进程移动到下一个队列中。

### 3.7 优先级调度（Priority）
1. 静态优先级调度
静态优先级调度算法是一种进程调度算法，它根据进程的优先级来调度进程。进程的优先级越高，越优先被调度执行。
静态优先级调度算法的优点是，它可以避免进程的饿死问题。
静态优先级调度算法的缺点是，如果一个进程的优先级过高，可能会导致其他进程被饿死。
2. 动态优先级调度

动态优先级调度算法是一种进程调度算法，它根据进程的实际运行情况来动态调整进程的优先级。
动态优先级调度算法的优点是，它可以避免进程的饿死问题。
缺点是，动态优先级调度算法需要额外的资源来维护进程的优先级信息。







