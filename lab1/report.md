# 操作系统

## 任务二

以下是我们认为本次实验中重要的几个知识点：

#### 1. 操作系统启动流程 (Bootstrapping)

*   **实验中的体现**:
    *   entry.S: 这是内核的入口点。它首先设置了初始的内核栈指针 `sp` 指向 `bootstacktop`，然后直接跳转到 C 语言的 `kern_init` 函数。
    *   init.c: `kern_init` 函数是 C 代码的起点。它首先清理了 BSS 段（未初始化的全局变量），然后调用 `cprintf` 打印启动信息。
*   **对应的OS原理**:
    *   **操作系统引导 (OS Booting)**: 任何 OS 都需要一个引导过程。通常由 Bootloader 将内核加载到内存，然后跳转到内核的入口点。本实验简化了这个过程，直接从内核入口 `kern_entry` 开始。
*   **理解与分析**:
    *   **关系**: 实验中的 entry.S 和 `kern_init` 是 OS 引导过程在内核阶段的微观实现。它展示了从机器相关的汇编代码（设置栈）过渡到高级语言（C函数）的关键一步。
    *   **差异**: 完整的 OS 引导过程要复杂得多，涉及 BIOS/UEFI、Bootloader（如 GRUB）等多个阶段。本实验聚焦于内核自身初始化的第一步，省略了前面的加载过程。

#### 2. SBI (Supervisor Binary Interface)

*   **实验中的体现**:
    *   sbi.h 和 sbi.c: 定义了 SBI 调用的接口和实现。`sbi_call` 函数通过 `ecall` 指令触发一次到 M-Mode (Machine Mode) 的陷入，请求底层固件的服务。
    *   `sbi_console_putchar` 函数就是一个具体的例子，它通过 SBI 调用来在控制台输出一个字符。这是上层 `cprintf` 函数最终依赖的底层输出能力。
*   **对应的OS原理**:
    *   **系统调用 (System Call)** 和 **特权级 (Privilege Levels)**: OS 原理中，用户程序通过系统调用（如 `int 0x80` 或 `syscall` 指令）陷入内核态，请求内核服务。这是一种跨越特权级的通信方式。
*   **理解与分析**:
    *   **关系**: SBI 调用和系统调用在机制上高度相似。它们都是通过特定的“陷入 (trap)”指令，从一个较低的特权级向一个较高的特权级请求服务。在 RISC-V 中，内核运行在 S-Mode (Supervisor Mode)，它通过 `ecall` 请求 M-Mode 固件的服务；而用户程序未来也会通过 `ecall` 请求 S-Mode 内核的服务。
    *   **差异**:
        *   **通信双方不同**: SBI 是 **内核 (S-Mode) 到 监视器/固件 (M-Mode)** 的通信。而常规的系统调用是 **用户程序 (U-Mode) 到 内核 (S-Mode)** 的通信。
        *   **目的不同**: SBI 的目的是让内核能使用硬件相关的底层功能（如电源管理、多核中断、控制台IO）。系统调用的目的是让应用程序能使用操作系统提供的抽象服务（如文件系统、进程管理）。

#### 3. 内核态的格式化输出

*   **实验中的体现**:
    *   printfmt.c: 实现了 `vprintfmt` 核心格式化逻辑，支持 `%d`, `%s`, `%x` 等多种格式。
    *   stdio.c: 基于 printfmt.c 封装了 `cprintf` 函数，将其输出目标设定为控制台（通过 `cputch` -> `cons_putc` -> `sbi_console_putchar`）。
*   **对应的OS原理**:
    *   **I/O 子系统** 和 **分层设计**: 操作系统通过分层的驱动程序和接口来管理复杂的 I/O 设备。上层应用使用统一的接口（如 `printf`），而底层驱动负责与具体硬件交互。
*   **理解与分析**:
    *   **关系**: 实验中的 `cprintf` -> `vprintfmt` -> `cputch` -> `sbi_console_putchar` 的调用链完美地展示了分层设计的思想。`cprintf` 提供了高级、易用的接口，而 `sbi_console_putchar` 负责与“硬件”（此处为 M-Mode 固件）打交道，中间各层负责不同的抽象。
    *   **差异**: 实验中实现的是一个简化的、内核专用的 `printf`，它不能在用户态直接使用，并且直接输出到物理控制台。而通用 OS 中的 `printf` 是标准库函数，它通过系统调用将数据写入内核，再由内核根据文件描述符决定输出到控制台、文件还是管道等。

#### 4. 初始内存布局

*   **实验中的体现**:
    *   memlayout.h: 定义了内核栈的大小 `KSTACKSIZE`。
    *   entry.S: 在 `.data` 段中分配了 `KSTACKSIZE` 大小的 `bootstack`，并将栈顶设置为 `bootstacktop`。
    *   init.c: `memset(edata, 0, end - edata)` 这行代码清空了 BSS 段。`edata` 和 `end` 是链接器脚本定义的符号，分别代表已初始化数据段的结束和整个内核镜像的结束。
*   **对应的OS原理**:
    *   **进程/内核内存映像 (Memory Image)**: 一个程序（包括内核本身）在加载到内存时，其地址空间会被划分为代码段 (.text)、数据段 (.data)、BSS 段 (.bss)、栈 (stack)、堆 (heap) 等区域。
*   **理解与分析**:
    *   **关系**: 实验中的代码是对 OS 原理中内存映像概念的直接实践。设置栈、清空 BSS 段都是内核为了正确运行而必须执行的内存初始化步骤。
    *   **差异**: 这只是内核最最原始的静态内存布局。一个完整的 OS 很快会建立复杂的动态内存管理机制（如伙伴系统、slab 分配器）和虚拟内存管理（页表），来为进程和内核自身动态分配和管理内存。当前的布局只是万里长征的第一步。

## 任务三

### 1.上下文切换

上下文（Context）中包含了进程运行状态相关的信息，包括寄存器、CPU的状态、内存地址空间。

PCB：管理进程的数据结构，保存进程的运行状态，如进程的PC、CPU的寄存器值、进程的优先级、进程的调度状态、进程的资源使用情况等。

#### 1.1 上下文切换的概念

上下文切换（Context Switch）是操作系统在运行多任务时，为了在多个任务之间切换执行而进行的操作。它涉及到保存当前任务的执行状态，并加载下一个任务的执行状态。上下文切换通常发生在以下几种情况：任务调度、中断处理、系统调用等。

#### 1.2 上下文切换的步骤

1. 保存当前进程1状态到PCB中。
2. 从进程2的PCB中加载进程2的运行状态。
3. 执行进程2的指令。
4. 保存进程2状态到PCB中。
5. 从进程1的PCB中恢复进程1的运行状态。
6. 执行进程1的指令。

### 2.进程调度

在上面的上下文切换中，我们通过将运行中的进程保存到PCB中，并切换到下一个进程的运行状态，实现了进程的切换。那么现在我们就会面临一个问题，当许多程序在运行时，我们在中断了原来的进程之后，操作系统内核中的调度器 (Scheduler) 会如何选择下一个进程进行运行呢？

#### 2.1 五状态模型
**状态**：创建、就绪、等待、运行、退出
创建：进程创建时，操作系统会为进程分配资源，并创建进程控制块（PCB）并保存进程信息。
就绪：进程创建成功后，操作系统会将进程加入就绪队列，等待CPU调度。
等待：进程等待某个事件发生，如文件I/O、网络I/O、设备I/O等。
运行：进程开始执行，CPU开始调度进程。
退出：进程执行完毕，操作系统会回收进程所占用的资源，并删除进程控制块。

#### 2.2 挂起进程模型
某进程长时间不能运行可以换至外存——就是挂起状态
1. 单挂起模型
**状态**：创建、就绪、阻塞、挂起、运行、退出
与五状态模型相比，单挂起模型增加了挂起状态。当进程处于挂起状态时，操作系统会将进程从内存中移除，并将其保存到外存中。当进程被唤醒时，操作系统会将进程从外存中加载到内存中，并将其状态设置为就绪状态。

2. 双挂起模型
**状态**：创建、就绪、阻塞、阻塞挂起、就绪挂起、就绪、运行、退出
双挂起模型在单挂起模型的基础上，进一步细化了挂起状态。它将挂起状态分为阻塞挂起和就绪挂起两种状态。

+ 当一个在内存中的阻塞进程因为内存紧张被换出时，它进入“阻塞挂起”状态，此时它位于外存。

- 如果这个处于“阻塞挂起”的进程，它所等待的事件完成了，它的状态就会变为“就绪挂起”，但它依然停留在外存。

* “就绪挂起”状态的进程，表明它已经准备好运行，只等待被换入内存。

+ 当操作系统有空闲内存时，会将“就绪挂起”的进程换入内存，此时它的状态就变成了“就绪”，可以等待被调度器选中并在CPU上运行。

### 3.进程调度算法

#### 3.1 先来先服务（FCFS）

先来先服务（First Come First Serve，FCFS）调度算法是一种简单的进程调度算法，它按照进程到达的顺序来调度进程。也就是说，先到达的进程先被调度执行，后到达的进程后执行。

#### 3.2 短进程优先（SPN）

短进程优先（Shortest Process Next，SPN）调度算法是一种进程调度算法，它按照进程执行时间长短来调度进程。也就是说，执行时间最短的进程优先被调度执行。

#### 3.3 最高响应比优先（HRRN）

最高响应比优先（Highest Response Ratio Next，HRRN）调度算法是一种进程调度算法，它根据进程的响应比来调度进程。响应比 = (等待时间 + 要求服务时间) / 要求服务时间。响应比越高的进程优先被调度执行。

#### 3.4 时间片轮转（RR）

时间片轮转（Round Robin，RR）调度算法是一种进程调度算法，它按照进程到达的顺序来调度进程，并为每个进程分配一个固定的时间片。当一个进程的时间片用完时，操作系统会将其从就绪队列中移除，并将其加入等待队列。然后，操作系统会从等待队列中选择下一个进程进行调度执行。

#### 3.5 多级队列调度（MQ）

多级队列调度（Multilevel Queue，MQ）是一种进程调度算法，它将进程按照优先级划分为多个队列，并使用不同的调度算法来调度每个队列中的进程。

#### 3.6 多级反馈队列调度（MLFQ）

多级反馈队列调度（Multilevel Feedback Queue，MLFQ）是一种进程调度算法，它将进程按照优先级划分为多个队列，并使用不同的调度算法来调度每个队列中的进程。

与多级队列调度不同的是，MLFQ算法允许进程在队列之间移动。当一个进程在一个队列中等待的时间过长时，操作系统会将该进程移动到下一个队列中。

#### 3.7 优先级调度（Priority）
1. 静态优先级调度
静态优先级调度算法是一种进程调度算法，它根据进程的优先级来调度进程。进程的优先级越高，越优先被调度执行。
静态优先级调度算法的优点是，它可以避免进程的饿死问题。
静态优先级调度算法的缺点是，如果一个进程的优先级过高，可能会导致其他进程被饿死。
2. 动态优先级调度
动态优先级调度算法是一种进程调度算法，它根据进程的实际运行情况来动态调整进程的优先级。
动态优先级调度算法的优点是，它可以避免进程的饿死问题。
缺点是，动态优先级调度算法需要额外的资源来维护进程的优先级信息。







