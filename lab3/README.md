# lab3

# Challenge 1：描述与理解中断流程

## 一、从异常/中断产生到返回的处理流程

处理器检测到异常/中断后在 scause 写入原因并在 sip/stip 中标记“待处理中断”，随后依据 stvec 跳转至统一入口 __alltraps，并以 sscratch 暂存陷入前的 sp，按预设 trapframe 布局在线程栈上依次保存 32 个通用寄存器与 sstatus、sepc、stval、scause，并将 trapframe 指针放入 a0 传递给 trap(tf)。trap(tf) 依据 scause 最高位区分中断与异常并分发：比如我们本次练习一中的时钟中断会进行续约下一次事件、维护 ticks 与观测输出等处理过程；异常路径按类型修正 epc。处理结束后返回到 __trapret，恢复 sstatus 与 sepc，再按 trapframe 回填所有通用寄存器，执行 sret 返回至陷入前的 PC；SIE 在陷入时被硬件清零，返回时按 SPIE 恢复，实现中断异常产生到处理的完整流程。

## 二、move a0, sp 的目的

该指令将当前 sp（指向栈上已构造完成的 trapframe）传递到 a0，使得后续调用的 C 函数 trap(tf) 能以 a0 作为参数获得 trapframe 起始地址，从而读取/修改通用寄存器与 CSR 备份，实现对异常/中断处上下文正确的保存与恢复。

## 三、SAVE_ALL 中寄存器的栈上位置如何确定

SAVE_ALL 在栈上的保存布局我们定义的 struct trapframe 严格一致：先按 struct pushregs 顺序快照 32 个通用寄存器，随后依次写入 status（sstatus）、epc（sepc）、badvaddr（stval）、cause（scause）。每个槽位大小由 REGBYTES 固定（在 RISC‑V 64 位为 8 字节），汇编以 STORE xN, KREGBYTES(sp) 的偏移写入，K 的取值与结构体字段一一对应；其中 sp 槽位保存的是陷入前的“旧 sp”，做法是先将旧 sp 暂存于 sscratch，再写回到 trapframe 对应位置以确保可逆恢复。


## 四、是否需要在 __alltraps 中对任何中断都保存所有寄存器

我们不必在 __alltraps 中对所有中断一律保存所有寄存器，但是保存所有寄存器的值能够在出现其他问题时更方便地进行调试，恢复中断/异常出现的场景，具体原因如下：
### 不需要保存所有寄存器的原因
从返回正确性的最低需求看，我们只需保证保存并恢复 sstatus、sepc、陷入前的 sp，以及可能被处理路径破坏的通用寄存器即可；在上述过程中 scause 与 stval 不参与返回流程，理论上可在处理中通过 read_csr 临时读取而不入栈。

并且，在恢复操作 RESTORE_ALL 中，我们也仅恢复 sstatus/sepc 与各通用寄存器中的值，并不恢复 scause/stval。

### 保存所有寄存器更加安全的原因
中断/异常陷入后进入 C 处理并可能经历多层调用链，只有全量快照才能保证任意路径变化下都能无损恢复现场；若在处理中重新开中断、允许嵌套陷入或发生调度/抢占，外层的 scause/stval 与寄存器会被新一次陷入覆盖，内存中的 trapframe 才是唯一可靠的历史状态；同时，保存 scause/stval 寄存器便于打印与问题复现；此外，调试时查看完整的寄存器状态有助于定位问题，尤其是在复杂的中断处理逻辑中。
综上所述，虽然并非所有寄存器都必须保存以保证正确返回，但为了系统的健壮性与调试便利性，通常建议在 __alltraps 中保存所有寄存器的值。

## Challenge 2：理解上下文切换机制
### 练习要求
回答：在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么？save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？

### 回答
首先我们先来看两条指令的作用：
 **`csrw sscratch, sp`**，这条汇编语句的意义是把**进入陷入时**的栈指针 `sp` 暂存到 CSR `sscratch`。这样在马上要为 trapframe 腾出空间、移动 `sp` 之前，先把“原始的 `sp`”备份到一个寄存器（`sscratch`）里。使用这一指令是由于CSR是特权寄存器，因此RISCV不能直接从CSR写到内存, 需要csrr把CSR读取到通用寄存器，再从通用寄存器STORE到内存，csrw指令可以直接把通用寄存器的值写入CSR，因此我们选择使用csrw指令把sp的值写入sscratch寄存器中。

然后我们讲解下一条指令 **`csrrw s0, sscratch, x0`**，这是一条“读并交换”CSR 的三元的RISC-V原子指令：把 `sscratch` 的旧值读到 `s0`，同时把存在x0寄存器中的**0**值 写回 `sscratch`。

我们使用这两条指令的最终结果是： `s0` 里拿到**进入陷入前的原始 `sp`**，随后用 `STORE s0, 2*REGBYTES(sp)` 把它存入 trapframe 对应的 `sp` 槽位（即 `pushregs.sp`）。 sp是“被打断上下文”的栈指针，我们需要把它保存下来，以便后续恢复现场时能回到正确的栈位置。如果什么都不做就改 sp，就丢失了“原始 sp”。因此先用一个不受当前栈移动影响的地方暂存它，最方便、最低开销的就是一个 CSR：sscratch。

随后把 `sscratch` 清零，**作为“我们现在处于内核陷入路径”的标记**。如果在保存现场过程中又发生“递归异常/中断”，入口代码可通过 `sscratch==0` 快速判断这次 trap 是发生在内核态的陷入处理里，从而走一条更稳妥的兜底路径（例如使用一个保底栈/只做最小化处理/直接 panic 等，而不是按用户/普通上下文那套流程再起一遍大栈框）。

我们看一个常见时序：我们刚进 __alltraps，执行了 csrw sscratch, sp，随后 addi sp, sp, -...、一通 STORE 在改动当前栈。万一这时又发生一次异常（比如栈越界/页失效/对齐错误/取指异常等），入口代码需要判定：

- 这是来自“普通上下文”（比如用户/内核正常执行路径被打断）？

- 还是来自“陷入处理内部”（我们保存现场还没做完）？

通过检查 sscratch 就能区分：
如果 sscratch!=0：说明那里还放着“普通上下文的原始 sp”，这是一条正常第一次陷入路径；如果 sscratch==0：说明我们正在处理陷入（已经把 sscratch 清为 0，当作哨兵），现在发生的是递归陷入，此时应避免再次使用同一套栈/同一份复杂流程，而是走一条简化/保底的路径（视你的向量入口代码设计而定：有的实现会换到一个每核的应急栈，有的会直接 panic，有的会简单打 log 后 sret，总之不走正常大路径以免“越陷越深”）。这也是为什么这里选择 csrrw（读回旧值+写 0）而不是简单 csrr 读：一个指令完成读+置哨兵，避免在“最脆弱”的窗口里多发一条写指令造成更大风险。


这两条指令配合使用，**把原始 `sp` 从即将被改动的地方转移到安全处（先进 `sscratch`，再进 trapframe），并把 `sscratch` 清零用作递归陷入的哨兵标记**。

那我们清楚上面这些内容之后，我们接下来重点分析一下后面一个问题，首先我们需要明确在 RISC-V 中，**硬件在进入 S 模式陷入时会自动写入几个重要的csr寄存器**：
```assembly
    csrr s1, sstatus
    csrr s2, sepc
    csrr s3, sbadaddr
    csrr s4, scause
```

在 RISC-V 的 S 模式中，当 CPU 发生陷入（trap）时，硬件会自动把与这次中断或异常有关的\*\*控制状态寄存器（CSR）\*\*写入特定寄存器。这些寄存器的值随后被保存进 `trapframe` 结构，以便内核在 C 层处理时可以读取。 `trapframe` 中的四个字段——`sstatus`、`sepc`、`stval`（在RISC-V特权架构的早起版本中叫 `sbadaddr`）和 `scause`——正是这四个关键的 CSR。


`SSTATUS` 保存当前 S 态（Supervisor mode）的全局状态控制信息，最重要的是中断使能相关的标志位。

* **SIE（Supervisor Interrupt Enable）**：为 1 时允许 S 态中断；为 0 时禁止。
* **SPIE（Supervisor Previous Interrupt Enable）**：保存进入陷入前 SIE 的旧值；执行 `sret` 时会把 SIE 恢复成 SPIE。
* **SPP**：指示陷入前的特权级（用户态或 S 态）。

进入陷入后，硬件会清掉 SIE 并把 SPIE 置成旧 SIE，防止处理中断的过程中再次被打断。返回时 `sret` 会用 SPIE 恢复中断状态。


`SEPC` 记录**触发陷入的那条指令的虚拟地址**。

* 如果是异常（例如缺页或非法指令），它保存那条出错指令的 PC；
* 如果是中断（例如时钟中断），它保存被打断指令的 PC。

处理完后，内核通常把 `sepc` 写回（或经过修改后写回），`sret` 指令会用它来恢复 PC，从而回到原执行流。


`SBADADDR` 提供**异常的附加信息**，帮助软件确定错误原因。

* 对于访存或取指异常，它会写入**出错的虚拟地址**；
* 对于非法指令异常，它可能写入**导致异常的指令内容**；
* 对于其他异常，标准允许它被置零。

例如缺页异常时，`stval` 告诉内核“哪个虚拟地址”访问失败，从而让页表填充或 panic 时能精确定位。


`SCAUSE` 指示**陷入原因**，并区分是中断还是异常：

* 最高位 bit 63 为 1 表示“中断”，为 0 表示“同步异常”；
* 低 bits 给出具体编码（如 5 = 定时器中断、8 = 系统调用、12 = 指令页错误、13 = 加载页错误 等）。
![alt text](image.png)

软件据此进行分发：如果是外设中断就进入外设处理；如果是异常则根据编码执行缺页、非法指令等分支逻辑。

这四个寄存器共同构成了**陷入上下文的核心元数据**：`sstatus` 描述处理器状态，`sepc` 确定返回点，`scause` 说明为什么陷入，`stval` 提供详细线索。操作系统保存它们，是为了让 C 层 `trap()` 能完全复原执行环境、正确处理异常并最终 `sret` 返回。

但是为什么我们存了4个寄存器，却只恢复其中两个呢？这是因为：scause/stval 是本次陷入（中断/异常）的诊断信息，C 端 trap()/trap_dispatch() 需要它们来判定陷入类型：外设中断？时钟中断？页故障？非法指令？（靠 scause）；获取异常附加信息：比如坏地址、问题指令地址等（靠 stval）；打印日志/统计/决定是否设下一次时钟事件等。
它们被保存在 trapframe 里，是为了传参给软件逻辑，不是为了“返回时复原机器状态”。因为**C 语言的陷入处理函数需要这些信息**来做分发与诊断：例如根据 `scause` 判断是外设中断、时钟中断还是缺页/非法指令异常；根据 `stval` 找到“坏地址”或问题指令；有时还会把它们打印出来或传给上层逻辑。把 `stval/scause` 存进 trapframe，就是把这次 trap 的上下文**传参**给 `trap(struct trapframe *tf)` 使用，处理结束后无需“复原”它们。

但是在我们恢复时， **返回时硬件只关心 `sepc` 与 `sstatus`**：我们需要恢复 `sstatus`（包含中断使能等位）和 `sepc`（让 `sret` 能回到正确的位置）。sepc告诉硬件从哪里继续执行；sstatus恢复 S 模式全局中断使能、特权级相关位等控制语义。而`scause/stval` 是“这次陷入的快照信息”，并不是“返回执行”所需的机器状态**——下一次 trap 发生时硬件会重新填它们，手动恢复也没有意义（多数实现允许写，但**写了也不影响 `sret` 的返回行为**），“强行恢复旧的 scause/stval”还可能污染后续的诊断（比如后面又发生一次新的陷入，却看到了上一回的 cause/tval）。所以保存只为“让软件读”，不恢复才是符合习惯与理性的设计。。因此 `RESTORE_ALL` 只恢复了 `sstatus` 与 `sepc`，没有恢复 `scause/stval`。


同时，我们可以关注到恢复时sp寄存器是最后恢复的，这是因为整个 trapframe 就建在当前 sp 指向的内存上。若你过早把 sp 改回“原始 sp”，随后的 LOAD 就会从错误的地址取数据（甚至把用户栈/别的区域当 trapframe 读）。于是流程是：先恢复除了 sp 以外的寄存器，最后一步再把“原始 sp”装回去。

同样的，为什么先恢复 sstatus/sepc 再恢复 GPR？事实上这不需要严格先后，但把“控制语义”（sstatus/sepc）尽早就位，可以让后面的恢复阶段一旦被中断/异常，也处于与原语义更接近的状态（比如中断屏蔽位、SPP、SPIE 状态等已经与要返回的环境一致），这在一些实现里是更稳妥的习惯。

还有一个小细节，我们都知道x0是零寄存器，那为什么要保存 x0呢？这是因为工程上为了让 struct trapframe 的“寄存器数组”与寄存器号一一对齐（第 0 个槽就是 x0，第 1 个槽就是 x1……），调试/打印/通用宏更方便。虽然 x0 恒为 0，但保存它不会出错，却能让布局规整。

最后的最后，我们总结一下SAVE_ALL/RESTORE_ALL 的栈框架布局，根据上面的分析，我们可以知道先存通用寄存器（GPR）：`x0, x1, x3..x31`（**跳过 x2**），**x2作为sp，需要特殊处理**，即先备份到 `sscratch`，再读回到 `s0`，最后 `STORE s0, 2*REGBYTES(sp)` 填进 trapframe 的 “sp 槽”。这样就把\*\*“原始 sp”\*\*按统一位置放进了 trapframe。如果直接 STORE x2, 2*REGBYTES(sp)，那保存的就是“新 sp”，而不是原来的 sp，这显然是错误的。所以要想保存“陷入前”的 sp，就必须在改 sp 之前先备份它。再取 CSR 的快照：  `sstatus → s1`，`sepc → s2`，`sbadaddr/stval → s3`，`scause → s4`；然后把 `s1..s4` 存到 trapframe **最后 4 个槽**（32、33、34、35 号槽位）。尤其要注意：**`s1/s2/s3/s4` 是临时容器**，只是把 CSR 的值搬到 GPR，再落到内存里（trapframe），不是说“s1 就是 sstatus 寄存器”“s2 就是 sepc”。它们仅仅是“搬运工具”。

> 一个简化示意真实偏移见代码：
>
> ```
> [ 0] x0
> [ 1] x1(ra)
> [ 2] x2(sp, 用 s0 回填)
> [ 3] x3(gp)
> ...
> [31] x31(t6)
> [32] sstatus 快照
> [33] sepc    快照
> [34] stval   快照（旧名 sbadaddr）
> [35] scause  快照
> ```
>

这样 `trap(struct trapframe* tf)` 就能**统一访问**：`tf->gpr[2]` 就是**进入陷入前**的 sp；`tf->status/epc/tval/cause` 是这次陷入的 CSR 快照。


## Challenge 3：完善异常中断
### 练习要求
编程完善在触发一条非法指令异常和断点异常，在 kern/trap/trap.c的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址，即“Illegal instruction caught at 0x(地址)”，“ebreak caught at 0x（地址）”与“Exception type:Illegal instruction"，“Exception type: breakpoint”。

### 回答：
